import { nextColor256 } from "./colors";
import { Cel, Layer, Sprite, Tileset } from "./sprite";
import fs from "fs";
import { tilesetToNextPatterns } from "./tileset";
import { celAttrs, celOffset } from "./cel";

export async function writeNextPatterns(tilesets: Tileset[], filename: string, colorFn = nextColor256()) {

    // Open the file for writing
    const stream = fs.createWriteStream(filename);

    for (const tileset of tilesets) {
        const patterns = tilesetToNextPatterns(tileset, colorFn);
        stream.write(patterns);
    }
    await stream.end();
    console.log(`Tileset patterns have been written to ${filename}`);
}


function spriteLabel(sprite: string) {
    return `_sprite_${sprite.replace(/[\-]/g, "_")}`;
}


/**
 * Assigns an index in the pattern memory to each sprite familty
 * Sprite families include different skins for the same sprite
 * The function calculates the biggest size in the memory pattern 
 * for all the cel frames with the different skins.
 * @param sprites 
 * @returns a map with the family name as key and the index in the pattern memory as value
 */
export function patternIndexes(sprites: Sprite[]): Map<string, number> {
    const indexes = new Map<string, number>();
    let index = 0;
    const families = spriteFamilies(sprites);
    for (const [family, layers] of families) {
        const maxTiles = Math.max(...layers.map(layer => layer.tileset.tiles.length));
        indexes.set(family, index);
        index += maxTiles;
    }

    if (index > 64) {
        throw new Error(`Too many patterns: ${index}`);
    }

    return indexes;
}

/**
 * Groups the layers of the sprites by family name
 * @param sprites 
 * @returns 
 */
export function spriteFamilies(sprites: Sprite[]): Map<string, Layer[]> {
    return groupBy(sprites.flatMap(sprite => sprite.layers), family_name);
}


function family_name(layer: Layer) {
    // Finds the ocurrence of the ":" character and returns the substring before
    // If the "-" character is not found, the function returns the whole string
    const index = layer.name.indexOf(":");
    return index < 0 ? layer.name : layer.name.substring(0, index);
}



function groupBy<T>(array: T[], key: (item: T) => string): Map<string, T[]> {
    const map = new Map<string, T[]>();

    for (const item of array) {
        const k = key(item);
        if (!map.has(k)) {
            map.set(k, []);
        }
        map.get(k)!.push(item);
    }

    return map;
}

// =================================================================================================
// C file containing the metadata for the sptrite slots
// =================================================================================================

export async function writeMetadata(sprites: Sprite[], metadataFile: string, metadataOutput: string) {
    const metadata = JSON.parse(fs.readFileSync(metadataFile, "utf-8"));
    const stream = fs.createWriteStream(metadataOutput);
    const families = spriteFamilies(sprites);

    const slots = metadata.slots as string[];
    const patIndexes = patternIndexes(sprites);
    let attrIndex = 0;
    writeMetadataHeader(stream);
    for (const slot of slots) {
        const patIndex = patIndexes.get(slot);
        const family = families.get(slot)!;
        const maxTiles = nMaxAttributes(family);
        const nFrames = family[0].cels.length;
        const nSkins = family.length;
        writeSpriteSlot(stream, slot, [attrIndex, maxTiles, patIndex!, nFrames, nSkins], spriteDefLabel(slot));

        attrIndex += maxTiles;
    }
    closeSpriteSlots(stream);

    for (const [family, layers] of families) {
        const label = spriteDefLabel(family);
        writeSpriteDefHeader(stream, label);
        for (const layer of layers) {
            writeSkinComment(stream, layer);
            for (const cel of layer.cels) {
                const [offsetX, offsetY] = celOffset(cel);
                const nTiles = cel.tilemap.filter(t => t !== null).length;
                const label = frameLabel(layer, cel)
                writeStructContent(stream, nTiles, offsetX, offsetY, label);
            }
        }
        writeEndStatement(stream);
    }

    for (const [family, layers] of families) {
        const patIndex = patIndexes.get(family) ?? 0;
        for (const layer of layers) {
            for (const cel of layer.cels) {
                const attrs = celAttrs(cel, patIndex);
                const label = frameLabel(layer, cel)
                writeSpriteAttrs(stream, label, attrs);
            }
        }
    }

    return closeStream(stream);
}

function nMaxAttributes(layer: Layer[]) {
    const cels = layer.flatMap(l => l.cels);
    return Math.max(...cels.map(c => c.tilemap.filter(t => t != null).length));
}

function writeMetadataHeader(stream: fs.WriteStream) {
    stream.write("// **** File generated by ase2next ***\n");
    stream.write("// **** Do not edit ***\n\n");
    stream.write('#include "sprite_slots.h"\n\n');
    stream.write('SpriteSlot spriteSlots[] = {\n');
}

function writeSpriteSlot(stream: fs.WriteStream, slot: string, values: number[], spriteDefRef: string) {
    stream.write(`\t//${slot}\n`);
    stream.write(`\t{ 0, ${values.join(", ")}, &${spriteDefRef}},\n`);
}

function closeSpriteSlots(stream: fs.WriteStream) {
    stream.write(`};\n\n`);
}

function spriteDefLabel(sprite: string) {
    return `sprite_def_${sprite.replace(/[\-]/g, "_")}`;
}

function writeSpriteDefHeader(stream: fs.WriteStream, label: string) {
    stream.write(`SpriteDef ${label}[] = {\n`);
}

function writeSkinComment(stream: fs.WriteStream, skin: Layer) {
    stream.write(`\t// ${skin.name}\n`);
}

function writeEndStatement(stream: fs.WriteStream) {
    stream.write(`};\n\n`);
}

function writeStructContent(stream: fs.WriteStream, ...content: Array<string | number>) {
    const cntString = content.map(c => typeof c === "string" ? c : c.toString()).join(", ");
    stream.write(`\t{${cntString}},\n`);
}

// Name to be used for the array holding the attributes of a frame in a skin
function frameLabel(layer: Layer, cel: Cel) {
    return `${layer.name}_${cel.frame.frameIndex}`.replace(/[\-\:]/g, "_");
}

function writeSpriteAttrs(stream: fs.WriteStream, label: string, attrs: Buffer) {
    stream.write(`uint8_t ${label}[] = { \n`);
    for (let line = 0; line < attrs.length; line += 5) {
        stream.write("\t");
        for (let col = 0; col < 5; col++) {
            stream.write(`0x${attrs.readUInt8(line + col).toString(16).padStart(2, '0')}, `);
        }
        stream.write("\n");
    }
    stream.write("};\n\n");
}

async function closeStream(stream: fs.WriteStream) {
    return new Promise<void>((resolve, reject) => {
        stream.end(() => {
            stream.on('finish', resolve);
            stream.on('error', reject);
        });
    });
}
